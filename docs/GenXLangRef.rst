============================
LLVM IR for the GenX backend
============================

.. contents::
    :local:

Introduction
============

The GenX backend accepts
:doc:`LLVM intermediate representation <../LangRef>`
with certain restrictions, and with additional GenX-specific intrinsics.

LLVM IR representation of vISA code
===================================

Linkage
-------

A kernel is represented by a function with ``dllexport`` linkage.

A non-kernel function is represented by a function with ``public`` linkage.

A subroutine is represented by a function with ``internal`` linkage. A subroutine
is allowed to be accessed from multiple kernels and non-kernel functions; the
GenX backend clones such a subroutine so it appears with each kernel and function
that uses it in the vISA.

No other linkage is supported.

Global variables are not supported. (The CM compiler has its own CMABI pass that
works around this by passing such variable into and out of any subroutine that
uses it.)

Kernel information
------------------

The genx.kernels named metadata node contains a metadata node
for each kernel, containing:

* 0: reference to Function
* 1: kernel name
* 2: asm name
* 3: kernel argument kinds
* 4: slm size in bytes

Types
-----

Only fundamental types that correspond to Gen types are allowed:

* i1 for predicate
* i8 for b/ub
* i16 for w/uw
* half for hf
* i32 for d/ud
* float for f
* i64 for q/uq
* double for df

Arbitrary size vectors of these types are allowed.

Arithmetic/logic operator
-------------------------

There is no vector width restriction on operands and result of an
arithmetic/logic operator.

Where the operands and result have the same type, and no saturation is
required, the corresponding LLVM IR instruction can be used, for example
``add``.

A floating point operation where saturation is required is represented by
the LLVM IR instruction followed by the ``llvm.genx.sat`` intrinsic.

For an integer operation, vISA allows the operands to have one type
and the result to have a different type. This is represented by an intrinsic,
typically with signed/unsigned variants and variants with saturation.
Saturation cannot be represented by a separate intrinsic as for floating
point, because the intermediate result in the EU's ALU has one more bit
than the execution size.

An intrinsic is also required where the operator does not have an LLVM IR
instruction equivalent, such as ``min``.


Load and store
--------------

Load and store instructions are allowed only to load/store from/to a static
alloca, i.e. ones that are removed by a mem2reg pass.

SIMD control flow
-----------------

``goto`` and ``join`` instructions are represented by ``llvm.genx.simdcf.goto``
and ``llvm.genx.simdcf.join`` instructions.

The EM (execution mask) result of the two intrinsics is then used to mask
execution inside the SIMD control flow:

* EM can be used as the predicate in wrregion, or the condition in a select,
  to mask the write of a result to a vector;

* to mask the result of a compare, use the EM result as the condition in a
  select whose "true" input is the compare, and whose "false" input is the
  old value of the predicate being written;

EM is fixed at v32i1. To use a subset of it (e.g. v16i1 in SIMD16 control flow),
use a shufflevector that extracts the subset, then use that as above.

As described in the spec for the SIMD control flow intrinsics, there is a set
of rules governing how the intrinsics and the EM values are used. The GenX
backend generates actual ``goto`` instructions only if the rules are adhered to.


GenX intrinsics
===============

.. include:: autogenerated/GenXLangRef.rstinc

