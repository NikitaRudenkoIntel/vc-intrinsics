============================
LLVM IR for the GenX backend
============================

.. contents::
    :local:

Introduction
============

The GenX backend accepts
:doc:`LLVM intermediate representation <../LangRef>`
with certain restrictions, and with additional GenX-specific intrinsics.

LLVM IR representation of vISA code
===================================

Linkage
-------

A kernel is represented by a function with ``dllexport`` linkage.

A non-kernel function is represented by a function with ``public`` linkage.

A subroutine is represented by a function with ``internal`` linkage. A subroutine
is allowed to be accessed from multiple kernels and non-kernel functions; the
GenX backend clones such a subroutine so it appears with each kernel and function
that uses it in the vISA.

No other linkage is supported.

Global variables are not supported. (The CM compiler has its own CMABI pass that
works around this by passing such variable into and out of any subroutine that
uses it.)

Kernel information
------------------

The genx.kernels named metadata node contains a metadata node
for each kernel, containing:

* 0: reference to Function
* 1: kernel name
* 2: asm name
* 3: kernel argument kinds
* 4: slm size in bytes

Types
-----

Only fundamental types that correspond to Gen types are allowed:

* i1 for predicate
* i8 for b/ub
* i16 for w/uw
* half for hf
* i32 for d/ud
* float for f
* i64 for q/uq
* double for df

Arbitrary size vectors of these types are allowed.

Arithmetic/logic operator
-------------------------

There is no vector width restriction on operands and result of an
arithmetic/logic operator.

Where the operands and result have the same type, and no saturation is
required, the corresponding LLVM IR instruction can be used, for example
``add``.

A floating point operation where saturation is required is represented by
the LLVM IR instruction followed by the ``llvm.genx.sat`` intrinsic.

For an integer operation, vISA allows the operands to have one type
and the result to have a different type. This is represented by an intrinsic,
typically with signed/unsigned variants and variants with saturation.
Saturation cannot be represented by a separate intrinsic as for floating
point, because the intermediate result in the EU's ALU has one more bit
than the execution size.

An intrinsic is also required where the operator does not have an LLVM IR
instruction equivalent, such as ``min``.


Load and store
--------------

Load and store instructions are allowed only to load/store from/to a static
alloca, i.e. ones that are removed by a mem2reg pass.

SIMD control flow
-----------------

SIMD control flow is not directly represented in LLVM IR. Instead, it can be
built using:

* a scalar conditional branch
  where the condition is the result of an ``llvm.genx.all`` or ``llvm.genx.any``
  of a vector condition;

* predication (using ``select``, or predicated ``llvm.genx.wrregion``).

Then, structured or unstructured SIMD control flow can be modelled
using LLVM IR as follows:

* There is a vXi1 execution mask (EM) (for SIMD width X). Within SIMD
  control flow, vector instructions that affect state are predicated by
  EM. (SIMD control flow of different widths cannot be mixed, although
  it can appear separately in the same function, so there is a separate
  EM for each width used in the function.)

* Each SIMD control flow join point has a vXi1 re-enable mask (RM)
  variable. It is initialized to 0.

* A SIMD conditional branch does the following:

  - For a channel that is enabled (bit set in EM) and wants to take the
    branch, its bit is cleared in EM and set in the branch target's RM.

  - For a forward branch, if all bits in EM are now zero, it branches to
    the next join point where any currently disabled channel could be
    re-enabled. For structured control flow, this is the join point of
    the current or next outer construct.

  - For a backward branch, if any bit in EM is 1, it branches to the
    earliest point where any currently disabled channel could be
    re-enabled. For structured control flow, this is the top of the
    innermost loop.

* A join point does the following:

  - re-enables channels from its RM variable: EM \|= RM. (If we know from
    the control flow structure that EM==0, as we do at an "else" and a
    loop exit, then we can instead use EM = RM, which makes the resulting
    optimized IR considerably simpler.)

  - resets its RM to 0

  - if EM is still all zero, it branches to the next join point where any
    currently disabled channel could be re-enabled.

LLVM IR using this model can be translated directly into vISA by the GenX
backend. However it also has an opportunity to analyze the LLVM IR and
spot where it can implement it using vISA ``goto`` and ``join`` instructions.


GenX intrinsics
===============

.. The rst-formatted comments in include/llvm/IR/IntrinsicsGenX.td are extracted
   and appended here to document the GenX specific intrinsics.

